(ns uberscriptify
  (:require
    [clojure.java.io :as io]
    [clojure.java.shell :as sh]
    [clojure.string :as string]
    [clojure.tools.cli :refer [parse-opts]]
    [scribe.opts :as opts])
  (:gen-class))

(def script-name (opts/detect-script-name))

(def stubdir "scripts")

(def vanilla-shebang
  "#!/usr/bin/env bb\n\n")

(def stream-shebang
  "#!/bin/sh\n\n#_(\n  \"exec\" \"bb\" \"-I\" \"$0\" \"$@\"\n  )\n\n")

(def cli-options
  [["-s" "--script SCRIPT" "Script to process into an uberscript"]
   ["-o" "--out OUTDIR" "Output directory"
    :default "uberscripts"]
   ["-h" "--help"]])

(defn get-classpath
  []
  (let [result (sh/sh "clojure" "-Spath")]
    (:out result)))

(defn create-uberscript
  [main-ns]
  (let [tmp (str ".tmp." main-ns)
        cp (get-classpath)
        cmd ["bb" "uberscript" tmp "-cp" cp "-m" main-ns]
        _result (apply sh/sh cmd)
        script (slurp tmp)]
    (.delete (io/file tmp))
    script))

(defn needs-stdin?
  [stub]
  (string/includes? stub "-I"))

(defn process
  [options]
  (let [{:keys [script out]} options
        stub (slurp (io/file stubdir script))
        uberscript (create-uberscript script)
        destination (str out "/" script)]
    (println "Uberscriptifying" script)
    (spit destination
          (str
            (if (needs-stdin? stub)
              stream-shebang
              vanilla-shebang)
            ";; Generated by uberscriptify, do not edit directly.\n\n"
            uberscript))
    (sh/sh "chmod" "+x" destination)
    (println "Done.")))


#_(process {:script "ftime" :out "uberscripts"})
#_(create-uberscript "ftime")

(def usage
  "Create uberscripts from namespaces in src. Specify script name with -s.

  SCRIPT_NAME -s foo")

(defn -main [& args]
  (let [parsed (parse-opts args cli-options)
        {:keys [options]} parsed]
    (or (some-> (opts/validate parsed usage)
                (opts/format-help script-name parsed)
                (opts/print-and-exit))
        (process options))))
