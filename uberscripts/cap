#!/usr/bin/env bb

;; Generated by uberscriptify, do not edit directly.

(ns doric.core
  (:refer-clojure :exclude [format name join split when])
  (:use [clojure.string :only [join split]]))

(defn- title-case-word [w]
  (if (zero? (count w))
    w
    (str (Character/toTitleCase (first w))
         (subs w 1))))

(defn title-case [s]
  (join " " (map title-case-word (split s #"\s"))))

(defn align [col & [data]]
  (or (keyword (:align col))
      :left))

(defn format [col & [data]]
  (or (:format col)
      identity))

(defn title [col & [data]]
  (or (:title col)
      (title-case
       (.replaceAll (clojure.core/name (let [n (:name col)]
                                         (if (number? n)
                                           (str n)
                                           n)))
                    "-" " "))))

(defn title-align [col & [data]]
  (keyword (or (:title-align col)
               (:align col)
               :center)))

(defn when [col & [data]]
  (:when col true))

(defn width [col & [data]]
  (or (:width col)
      (apply max (map count (cons (:title col)
                                  (map str data))))))

(defn format-cell [col s]
  ((:format col) s))

(defn align-cell [col s align]
  (let [width (:width col)
        s (str s)
        s (cond (<= (count s) width) s
                (:ellipsis col) (str (subs s 0 (- width 3)) "...")
                :else (subs s 0 width))
        len (count s)
        pad #(apply str (take % (repeat " ")))
        padding (- width len)
        half-padding (/ (- width len) 2)]
    (case align
      :left (str s (pad padding))
      :right (str (pad padding) s)
      :center (str (pad (Math/ceil half-padding))
                   s
                   (pad (Math/floor half-padding))))))

(defn header [th cols]
  (for [col cols :when (:when col)]
    (th col)))

(defn body [td cols rows]
  (for [row rows]
    (for [col cols :when (:when col)]
      (td col row))))

(defn- col-data [col rows]
  (map #(get % (:name col)) rows))

(defn- column1 [col & [data]]
  {:align (align col data)
   :format (format col data)
   :title (title col data)
   :title-align (title-align col data)
   :when (when col data)})

(defn- column-map [col]
  (if (map? col)
    col
    {:name col}))

(defn- columns1 [cols rows]
  (for [col cols :let [col (column-map col)]]
    (merge col
           (column1 col (col-data col rows)))))

(defn- format-rows [cols rows]
  (for [row rows]
    (into {}
          (for [col cols :let [name (:name col)]]
            [name (format-cell col (row name))]))))

(defn- column2 [col & [data]]
  {:width (width col data)})

(defn- columns2 [cols rows]
  (for [col cols]
    (merge col
           (column2 col (col-data col rows)))))

;; data formats
(defn bar [x]
  (apply str (repeat x "#")))

;; table formats
(def csv 'doric.csv)
(def html 'doric.html)
(def org 'doric.org)
(def raw 'doric.raw)

;; table format helpers
;; aligned th and td are useful for whitespace sensitive formats, like
;; raw and org
(defn aligned-th [col]
  (align-cell col (:title col) (:title-align col)))

(defn aligned-td [col row]
  (align-cell col (row (:name col)) (:align col)))

;; unalighed-th and td are useful for whitespace immune formats, like
;; csv and html
(defn unaligned-th [col]
  (:title col))

(defn unaligned-td [col row]
  (row (:name col)))

(defn mapify [rows]
  (let [example (first rows)]
    (cond (map? rows) (for [k (sort (keys rows))]
                        {:key k :val (rows k)} )
          (vector? example) (for [row rows]
                              (into {}
                                    (map-indexed (fn [i x] [i x]) row)))
          (map? example) rows)))

(defn table*
  {:arglists '[[rows]
               [opts rows]
               [cols rows]
               [opts cols rows]]}
  [& args]
  (let [rows (mapify (last args))
        [opts cols] (case (count args)
                      1 [nil nil]
                      2 (if (map? (first args))
                          [(first args) nil]
                          [nil (first args)])
                      3 [(first args) (second args)])
        cols (or cols (keys (first rows)))
        format (or (:format opts) org)
        _ (require format)
        th (ns-resolve format 'th)
        td (ns-resolve format 'td)
        render (ns-resolve format 'render)
        cols (columns1 cols rows)
        rows (format-rows cols rows)
        cols (columns2 cols rows)]
    (render (cons (header th cols) (body td cols rows)))))

(defn table
  {:arglists '[[rows]
               [opts rows]
               [cols rows]
               [otps cols rows]]}
  [& args]
  (apply str (join "\n" (apply table* args))))
(ns doric.org
  (:refer-clojure :exclude [join])
  (:use [clojure.string :only [join]]
        [doric.core :only [aligned-th aligned-td]]))

(def th aligned-th)

(def td aligned-td)

(defn render [table]
  (let [spacer (str "|-"
                    (join "-+-"
                          (map #(apply str (repeat (.length %) "-"))
                               (first table)))
                    "-|")]
    (concat [spacer
             (str "| " (join " | " (first table)) " |")
             spacer]
            (for [tr (rest table)]
              (str "| " (join " | " tr) " |"))
            [spacer])))
(ns cap.xdg)

(defn dirs
  [env]
  (let [home (get env "HOME")
        data-home (get env "XDG_DATA_HOME")
        config-home (get env "XDG_CONFIG_HOME")
        cache-home (get env "XDG_CACHE_HOME")
        state-home (get env "XDG_STATE_HOME")]
    #:xdg{:data-home (or data-home (format "%s%s" home "/.local/share"))
          :config-home (or config-home (format "%s%s" home "/.config"))
          :cache-home (or cache-home (format "%s%s" home "/.cache"))
          :state-home (or state-home (format "%s%s" home "/.local/state"))}))

(comment
  (into {} (get (System/getenv) "HOME"))
  (dirs (System/getenv))
  (dirs {"HOME" "/somewhere/else"
         "XDG_DATA_HOME" "/foo/data"})
  )
(ns scribe.string
  "String utilities."
  (:require [clojure.string :as string]))

(defn- find-indent
  [string]
  (let [candidate (->> (string/split-lines string)
                       (next)
                       (filter seq)
                       first)
        [_ indent] (when candidate (re-matches #"^(\s+).*" candidate))]
    indent))

(defn dedent
  "Remove leading indent on strings. Typically called on strings defined in
  scripts that are to be printed to the terminal. If leading indent is not
  passed, it will be detected from the first line with leading whitespace."
  ([string]
   (dedent (find-indent string) string))
  ([indent string]
   (cond->> (string/split-lines string)
     indent (map #(string/replace % (re-pattern (str "^" indent)) ""))
     :always (string/join "\n"))))
(ns scribe.opts
  "A set of functions to handle command line options in an opinionated
  functional manner. Here is the general strategy:

  1. Args are parsed by clojure.tools.cli.
  2. The parsed args are examined for errors and the --help flag with a pure
     function.
  3. If errors are found, an appropriate message (optionally with usage) is
     assembled with a pure function.
  4. The message is printed and the script exits.

  Most of the above is pure, and therefore testable. Here's an example main
  function:

    (defn -main
      [& args]
      (let [parsed (parse-opts args [[\"-h\" \"--help\" \"Show help\"]
                                     [\"-n\" \"--name NAME\" \"Name to use\" :default \"world\"]])
            {:keys [name]} (:options parsed)]
        (or (some-> (opts/validate parsed usage-text)
                    (opts/format-help parsed)
                    (opts/print-and-exit))
            (println \"Hello\" name))))

  For a more complete sample script, check out `samples` in the repository."
  (:require [babashka.tasks :as tasks]
            [clojure.java.io :as io]
            [clojure.string :as string]
            [scribe.string]))

(defn validate
  "Look for the most common of errors:
  * `--help` was passed
  * clojure.tools.cli detected errors

  To detect other errors specific to a given script, wrap the call with an
  `or`, like this:

  (or (opts/validate parsed usage-text)
      (script-specific-validate parsed))

  The script-specific-validate function should return a map with information
  about the error that occurred. The keys are:
  * :message - (optional) Message to be printed
  * :exit - The numeric exit code that should be returned
  * :wrap-context - Whether or not to wrap the message with script help heading
                    and options documentation"
  [parsed usage]
  (let [{:keys [errors options]} parsed
        {:keys [help]} options]
    (cond
      help
      {:exit 0
       :message usage
       :wrap-context true}

      errors
      {:exit 1
       :message (string/join "\n" errors)
       :wrap-context true})))

(defn detect-script-name
  "Detect the name of the currently running script, for usage in the printed
  help."
  ([]
   (or (some->> (tasks/current-task)
                :name
                (format "bb %s"))
       (some-> (System/getProperty "babashka.file")
               detect-script-name)
       ;; Fallback if we're using the REPL for development
       "script"))
  ([filename]
   (.getName (io/file filename))))

(def ^:private help-fmt
  (scribe.string/dedent
    "usage: %s [opts]

    %s

    options:
    %s"))

(defn format-help
  "Take an error (as returned from `validate`) and format the help message
  that will be printed to the end user."
  ([errors parsed]
   (format-help errors (detect-script-name) parsed))
  ([errors script-name-or-ns parsed]
   (let [script-name (str script-name-or-ns)
         {:keys [summary]} parsed
         {:keys [message exit wrap-context]} errors
         final-message (-> message
                           scribe.string/dedent
                           (string/replace "SCRIPT_NAME" script-name))]
     {:help (if wrap-context
              (format help-fmt script-name final-message summary)
              final-message)
      :exit exit})))

(defn print-and-exit
  "Print help message and exit. Accepts a map with `:help`
  and `:exit` keys.

  Uses the :babashka/exit ex-info trick to exit Babashka."
  [{:keys [help exit]}]
  (throw (ex-info help {:babashka/exit exit})))
(ns cap.multi
  (:require [clojure.tools.cli :refer [parse-opts]]
            [scribe.opts :as opts]))

(defn find-errors
  [usage parsed subcommands]
  (or (opts/validate parsed usage)
      (and subcommands
           (let [{:keys [arguments]} parsed
                 subcommand (-> arguments first keyword)]
             (cond
               (nil? subcommand)
               {:exit 1
                :message usage}

               (not (contains? subcommands subcommand))
               {:message (str "Invalid subcommand: " (name subcommand))
                :exit 1})))))

(defn entry
  ([opts]
   (entry opts *command-line-args*))
  ([opts args]
   (entry opts args :top []))
  ([opts args cmd result]
   (let [{:keys [usage cli-options validate-fn subcommands]} opts
         script-name (or (:script-name opts)
                         (opts/detect-script-name))
         parsed (-> (parse-opts args cli-options :in-order true)
                    (assoc :command cmd))
         [subcommand & subargs] (:arguments parsed)
         subcommandkey (keyword subcommand)
         subcommandopts (get subcommands subcommandkey)]
     (or (some-> (or (find-errors (or usage "") parsed subcommands)
                     (and validate-fn
                          (validate-fn parsed)))
                 (opts/format-help script-name parsed)
                 (opts/print-and-exit))
         (if subcommandopts
           (entry (assoc subcommandopts :script-name (format "%s %s" script-name subcommand)) subargs subcommandkey (conj result parsed))
           (conj result parsed))))))

(comment
  (def try-opts
    {:cli-options [["-h" "--help" "Show help"]
                   ["-p" "--path PATH" "Specify path to operate on"]]
     :usage "top"
     :subcommands {:foo {:cli-options [["-h" "--help" "Show help"]
                                       ["-d" "--dath DATH" "Specify path to operate on"]]
                         :usage "foo"
                         :subcommands {:bar {:cli-options [["-h" "--help" "Show help"]
                                                           ["-g" "--gath GATH" "Specify path to operate on"]]
                                             :usage "bar"
                                             }}}}})
  (entry try-opts ["-p" "foobarpath" "foo" "-d" "test" "bar" "-g" "final"])
  (entry try-opts ["foo" "bar" "-h"])
  (entry try-opts ["foo" "-h"])
  (entry try-opts ["-h"])
  (entry try-opts [])
  )
(ns cap.db
  (:require [babashka.pods :as pods]
            [cheshire.core :as json]
            [clojure.string :as str]
            #?@(:bb []
                :clj [[honey.sql :as sql]
                      [honey.sql.helpers :as helpers]]))
  (:import (java.time LocalDateTime ZonedDateTime ZoneId)
           (java.time.format DateTimeFormatter)))

(pods/load-pod 'org.babashka/go-sqlite3 "0.2.7")
(require '[pod.babashka.go-sqlite3 :as sqlite])

#?(:bb (do (require '[babashka.deps :as deps])
           (deps/add-deps '{:deps {com.github.seancorfield/honeysql {:mvn/version "2.7.1310"}}})
           (require '[honey.sql :as sql])
           (require '[honey.sql.helpers :as helpers])))

(defn table-info
  [database table-name]
  (first (sqlite/query database ["select * from sqlite_schema where type = ? and name = ?" "table" table-name])))

(defn has-table?
  [database table-name]
  (boolean (table-info database table-name)))

(defn init
  "Update database to the latest version, creating it if it doesn't exist."
  [config]
  (let [{:db/keys [location]} config]
    (sqlite/query location ["PRAGMA journal_mode=WAL"])
    (when-not (has-table? location "captures")
      (println "Adding captures table")
      (sqlite/query location ["create table captures (id integer primary key, name text, directory text, session text, attributes text, created_at text default current_timestamp)"]))
    (when-not (has-table? location "lines")
      (println "Adding lines table")
      (sqlite/query location ["create table lines (id integer primary key, capture_id integer, line text)"]))
    ; (when-not (str/includes? (:sql (table-info location "captures")) "created_at")
    ;   (println "Adding column created_at to captures")
    ;   (sqlite/query location ["alter table captures add column created_at text default datetime('now')"])
    ;   (sqlite/execute! location ["update captures set created_at = datetime('now')"]))
    ))

(defn add-capture-query
  [name directory session attributes]
  (sql/format
    {:insert-into :captures
     :columns [:name :directory :session :attributes]
     :values [[name directory session (json/generate-string attributes)]]}))

(defn add-capture
  [{:db/keys [location]} name directory session attributes]
  (let [{:keys [last-inserted-id]} (sqlite/execute! location (add-capture-query name directory session attributes))]
    {:id last-inserted-id}))

(defn add-line-query
  [capture-id line]
  (sql/format
    {:insert-into :lines
     :columns [:capture_id :line]
     :values [[capture-id line]]}))

(defn add-line
  [{:db/keys [location]} capture line]
  (let [{:keys [last-inserted-id]} (sqlite/execute! location (add-line-query (:id capture) line))]
    {:id last-inserted-id}))

(defn find-captures-query
  [{:keys [name directory session]} {:keys [limit]}]
  (cond-> {:select :*
           :from [[:captures :c]]
           :join [[{:select [:capture_id [[:count :id] :line_count]]
                    :from :lines
                    :group-by :capture_id}
                   :l]
                  [:= :c/id :l/capture_id]]
           :order-by [[:created_at :desc]]}
    name (helpers/where [:= :name name])
    directory (helpers/where [:= :directory directory])
    session (helpers/where [:= :session session])
    limit (helpers/limit limit)
    :finally (sql/format)))

(def formatter (DateTimeFormatter/ofPattern "yyyy-MM-dd HH:mm:ss"))

(defn parse-sqlite-date
  [sqlite-date]
  (-> sqlite-date
      (LocalDateTime/parse formatter)
      (ZonedDateTime/of (ZoneId/of "UTC"))
      (.withZoneSameInstant (ZoneId/systemDefault))))

(defn decode-captures
  [{:keys [created_at] :as db-capture}]
  (-> db-capture
      (update :attributes json/parse-string true)
      (dissoc :created_at)
      (assoc :created-at (parse-sqlite-date created_at))))

(defn find-captures
  [{:db/keys [location]} args opts]
  (->> (sqlite/query location (find-captures-query args opts))
       (mapv decode-captures)))

(defn get-capture-query
  [id]
  (sql/format {:select :*
               :from :captures
               :where [:= :id id]}))

(defn get-capture
  [{:db/keys [location]} id]
  (->> (sqlite/query location (get-capture-query id))
       (mapv decode-captures)
       first))

(defn find-lines-query
  [id {:keys [limit]}]
  (cond-> {:select :*
           :from :lines
           :where [:= :capture_id id]
           :order-by [:id]}
    limit (helpers/limit limit)
    :finally (sql/format)))

(defn get-lines
  [{:db/keys [location]} capture opts]
  (->> (sqlite/query location (find-lines-query (:id capture) opts))
       ; (mapv decode-lines)
       ))



(comment
  (sqlite/execute! "foo.db" ["create table foo (bar)"])
  (sqlite/execute! "foo.db" ["insert into foo (bar) values (?)" "bar"])
  (sqlite/query    "foo.db" ["select * from foo"])
  (sqlite/query    "foo.db" ["PRAGMA journal_mode=WAL"])
  (sqlite/query    "foo.db" ["select * from sqlite_schema where type = 'table' and name = 'fo'"])

  (sqlite/query "cap.db" ["pragma foreign_keys = on"])
  (sqlite/query "cap.db" ["pragma foreign_keys"])
  (sqlite/execute! "cap.db" ["insert into captures (name) values (?)" "second"])
  (sqlite/execute! "cap.db" ["insert into attributes (capture_id) values (?)" 1])
  (sqlite/execute! "cap.db" ["delete from captures where id = ?" 1])
  (sqlite/execute! "cap.db" ["insert into attributes values (3, 4)"])

  (init {:db/location "cap.db"})
  (add-capture-query "Generated" "/home/nate" "0f1b2823-efa4-4b4a-9e38-64b3ac5f5632" {})
  (add-capture {:db/location "cap.db"} "Generated" "/home/nate" "0f1b2823-efa4-4b4a-9e38-64b3ac5f5632" {})

  (find-captures-query {:directory "/home/nate" :session "foobarsession"} {:limit 2})
  (find-captures {:db/location "cap.db"} {:directory "/home/nate/projects/bb-scripts"} {:limit 2})

  (add-line-query 2 "test log line")
  (add-line {:db/location "cap.db"} {:id 2} "test log line")

  (find-lines-query 2 nil)
  (get-lines {:db/location "cap.db"} {:id 2} nil)

  (get-capture-query 14)
  (get-capture {:db/location "cap.db"} "14")

  (table-info "cap.db" "captures")

  (sqlite/execute! "foo.db" ["create table foo (bar)"])
  )

(ns cap
  (:require [cap.db :as db]
            [cap.multi :as multi]
            [cap.xdg :as xdg]
            [doric.org]
            [doric.core :as doric]
            [babashka.fs :as fs]
            [babashka.process :as p]
            [clojure.string :as str]
            [clojure.pprint :refer [pprint]])
  (:import (java.time Duration ZonedDateTime)))

(def self-script (System/getProperty "babashka.file"))

(defn current-directory [] (System/getenv "PWD"))
(defn current-session [] (or (System/getenv "CAP_SESSION_ID") "no-session"))

(defn capture
  [config options]
  (let [capture-name (:name options)
        capture (db/add-capture config capture-name (current-directory) (current-session) {})]
    (loop [line (read-line)]
      (when line (db/add-line config capture line)
        (println line)
        (recur (read-line))))))

(defn format-duration
  [duration]
  (cond
    (> 1 (.toHours duration))
    (str (.toMinutesPart duration) "m" (.toSecondsPart duration) "s")

    (> 1 (.toDays duration))
    (str (.toHoursPart duration) "h" (.toMinutesPart duration) "m")

    (> 7 (.toDays duration))
    (str (.toDaysPart duration) "d" (.toHoursPart duration) "h")

    :else
    (str (.toDaysPart duration) "d")))

(defn calculate-ago
  [now dt]
  (format-duration (Duration/between dt now)))

(defn shell-init-str
  []
  (format "export CAP_SESSION_ID=%s" (random-uuid)))

(defn simple-line
  [{:keys [id name directory ago]}]
  (format "%d: %s (in %s) %s" id name directory ago))

(defn interactive-picker
  [data]
  (p/shell {:continue true :in (str/join "\n" data)} (format "fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-d:preview-page-down --bind=ctrl-u:preview-page-up --header \"Enter prints lines, CTRL-C exits\" --preview \"echo {} | cut -d: -f1 | head -1 | xargs -I %% sh -c '%s get --limit 10 -c %%'\" --bind \"enter:execute(echo {} | cut -d: -f1 | head -1 | xargs -I %% sh -c '%s get -c %%')+abort\"" self-script self-script)))

(defn get-captures
  [config {:keys [all-sessions all-directories previous limit id interactive]}]
  (let [args (cond-> {}
               (not all-sessions) (assoc :session (current-session))
               (not all-directories) (assoc :directory (current-directory)))
        captures (db/find-captures config args {:limit (if previous 1 limit)})]
    (cond
      id (run! println (map :line (db/get-lines config (db/get-capture config id) {:limit limit})))
      interactive (interactive-picker (->> (map #(assoc % :ago (calculate-ago (ZonedDateTime/now) (:created-at %))) captures)
                    (map simple-line)))
      previous (run! println (map :line (db/get-lines config (first captures) {:limit limit}))))))

(defn list-captures
  [config {:keys [all-sessions all-directories previous limit list-raw]}]
  (let [args (cond-> {}
               (not all-sessions) (assoc :session (current-session))
               (not all-directories) (assoc :directory (current-directory)))
        captures (db/find-captures config args {:limit (if previous 1 limit)})]
    (cond
      list-raw (->> (map #(assoc % :ago (calculate-ago (ZonedDateTime/now) (:created-at %))) captures)
                    (run! (comp println simple-line)))
      :else (->> (map #(assoc % :ago (calculate-ago (ZonedDateTime/now) (:created-at %))) captures)
                 (doric/table [:name :directory :session :ago {:name :line_count :title "Line Count"}])
                 println))))

(defn print-shell-init
  []
  (println (format "export CAP_SESSION_ID=%s" (str (random-uuid)))))

(def opts
  {:cli-options [["-h" "--help" "Show help"]
                 ["-d" "--db DB" "Database file"]]
   :usage "Capture and retrieve output in the shell.

          Available subcommands:

          add - Add a new capture
          get - Retrieve a previous capture
          init - Initialize database for capture data
          list - List previous captures
          shell-init - Print out exports to initialize the shell session.

          Pass '-h' to see further help on each subcommand."
   :subcommands {:add {:cli-options [["-h" "--help" "Show help"]
                                     ["-n" "--name NAME" "Capture name."]
                                     ["-d" "--directory DIRECTORY" "Directory to associate with capture."]
                                     ["-s" "--session SESSION" "Session to associate with capture."]]
                       :usage "Adds a capture."}
                 :init {:cli-options [["-h" "--help" "Show help"]]
                        :usage "Initialize."}
                 :get {:cli-options [["-h" "--help" "Show help"]
                                     ["-S" "--all-sessions" "Return captures from all sessions."]
                                     ["-D" "--all-directories" "Return captures from all directories."]
                                     ["-p" "--previous" "Retrieve the most previous capture" :default true]
                                     ["-c" "--id ID" "Retrieve capture by id"]
                                     ["-I" "--interactive" "Interactively select capture"]
                                     ["-n" "--limit LIMIT" "Number of lines to return" :default 100]]
                       :usage "Retrieve a capture."}
                 :shell-init {:cli-options [["-h" "--help" "Show help"]]
                        :usage "Emit shell initialization."}
                 :list {:cli-options [["-h" "--help" "Show help"]
                                      ["-S" "--all-sessions" "Return captures from all sessions."]
                                      ["-D" "--all-directories" "Return captures from all directories."]
                                      ["-r" "--list-raw" "List captures 1 per line"]
                                      ["-n" "--limit LIMIT" "Number of captures to list" :default 10]]
                        :usage "List captures."}
                 }})

(defn init
  [config _opts]
  (db/init config)
  (println "Initialization complete."))

(defn -main [& _args]
  (let [parsed (multi/entry opts)
        combined-options (apply merge (map :options parsed))
        {:xdg/keys [data-home]} (xdg/dirs (System/getenv))
        db-location (or (-> parsed first :options :db)
                        (str (fs/path data-home "cap/captures.db")))
        config {:db/location db-location}]
    (when-not (fs/exists? db-location)
      (->> db-location fs/parent fs/create-dirs))
    ; (pprint parsed)
    ; (pprint config)
    (case (-> parsed second :command)
      :add (capture config combined-options)
      :get (get-captures config combined-options)
      :list (list-captures config combined-options)
      :shell-init (print-shell-init)
      :init (init config combined-options))))
(ns user (:require [cap])) (apply cap/-main *command-line-args*)